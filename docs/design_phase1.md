# 第一阶段设计文档

[toc]

本文面向课程教师与助教，介绍棋类对战平台第一阶段的整体设计方案。文档主要讨论核心模块的划分、类设计的理由、涉及的设计模式以及与后续扩展的关系。写作上尽量保持简洁清晰，避免堆砌细节，让读者能快速理解项目结构与思路。

---

## 1. 项目概述

本项目旨在构建一个可扩展的棋类对战平台。目前阶段要求实现命令行版本的五子棋与简化围棋，包括基本对弈逻辑、回合管理、保存/加载以及最基础的单元测试覆盖。

本阶段的重点不在于复杂规则，而在于一个**干净清晰、便于扩展的 OOP 框架**。后续无论加 AI、加 GUI，还是添加新的棋类类型，都能在当前结构上自然延伸。

---

## 2. 目录结构

```
README.md
docs/
	design_phase1.md
src/
	__init__.py
	main.py
	client/
		console_client.py
	core/
		board.py
		player.py
		game.py
		gomoku.py
		go.py
		factory.py
		serialization.py
tests/
	test_board.py
	test_player.py
	test_game.py
	test_gomoku.py
	test_go.py
	test_factory.py
```

目录层次尽量保持“看到文件名就能猜到内容”的风格，降低阅读成本。

---

## 3. 设计目标与约束

* **教学友好**：结构比性能更重要，逻辑比技巧更重要。
* **扩展方便**：新的棋类、新的前端形式都要能相对独立地接入。
* **规则简化**：围棋采用教学版规则，专注于核心行为；五子棋实现五连判定即可。
* **可测试**：关键路径可单元测试，避免逻辑耦合导致的难以验证。

---

## 4. 核心 OOP 思路

项目从一开始就按“棋类游戏的共性——落子、轮转、胜负判定——与各自规则的差异”去拆分：

* **抽象 Game**：把所有棋类共同需要的部分放到 `Game` 抽象类里。
* **封装 Board**：棋盘本身的二维状态由 `Board` 统一管理，避免子类重复操作数组。
* **严格单一职责**：棋盘只管存状态，Game 只管棋规，Player 只管玩家信息。
* **尽量少耦合**：客户端（前端）不直接读写棋盘内部数组，统一通过接口互动。

整体结构干净，便于修改和阅读。

---

## 5. 类设计说明

以下介绍各类存在的原因，而不是只罗列方法：

### Board

负责棋盘这一“公共资源”的状态管理。
为什么单独拆出一个类？因为棋盘操作非常频繁，如果散落在各个 Game 子类中，会混乱且难以维护。

关键功能：访问/修改棋子、越界检查、遍历。

---

### Player

轻量级实体类。区分黑白方、用于显示。没有业务逻辑，保持简单即可。

---

### Game（抽象类）

这是整个项目的“骨架”。

公共责任包括：

* 管理回合
* 记录历史用于悔棋
* 处理投降、过手等与棋类无关的通用动作
* 提供工具方法（如 `_switch_turn()`）供子类使用

真正不同的部分（例如“什么算合法落子”“是否形成五连”）由子类实现。

---

### GomokuGame

在抽象骨架基础上实现：

* 合法性检查
* 横、竖、斜四个方向的五连判定
* 棋盘满时判平局

实现难度不大，但能很好地演示模板方法模式的优势。

---

### GoGame（简化版）

重点逻辑：

* 气的计算
* 提子逻辑
* 自杀禁手
* 连续 pass 的终局规则
* 简化计分法（“盘上子 + 提子数”）

由于真实围棋规则过于复杂，这里采用课程提供的教学版逻辑，让结构能保持清晰。

---

### GameFactory

典型的 **简单工厂模式**。

客户端只需要传入字符串 `"gomoku"` 或 `"go"` 就能拿到相应游戏实例，而不用关心具体类名与构造方法。将游戏的组织权集中到一个地方，使客户端代码保持干净。

---

### serialization

负责把棋局状态打包成 JSON、再还原成 Game 对象。

需要保存的内容包括：

* 棋盘二维状态
* 当前轮次
* 游戏类型
* 围棋特有的捕获数与 pass 计数

序列化放在独立模块，避免污染核心逻辑。

---

### ConsoleClient

命令行前端。功能包括：

* 读取用户输入
* 把输入解析成 Game 方法
* 显示棋盘与状态
* 处理保存、加载、悔棋等指令

它不直接操作棋盘内部，只依赖公开接口，从而保证前后端真正解耦。

---

## 6. 使用的设计模式

### 1. 工厂模式

用于游戏对象的创建。减少客户端对具体类的依赖，提高扩展能力。

### 2. 模板方法

体现于 Game 抽象类。
公共流程写在基类，棋类差异放在子类，避免重复代码。

### 3. 轻量依赖注入

ConsoleClient 不自己 new 游戏，而是接受工厂。
虽不是完整的 DI 框架，但足够提升模块之间的独立性。

---

## 7. 前端 / 后端分层

* **后端：src/core**

  * 规则、棋盘、序列化全都放在这里。
  * 不涉及任何显示逻辑。

* **前端：src/client**

  * 目前是命令行界面。
  * 未来可以替换成 Tkinter、Qt 或 web 前端，而无需修改核心逻辑。

这种分层方式虽然简单，但清晰易维护，也是课程里比较希望学生掌握的工程化思路。

---

## 8. 数据流示例

以“五子棋落子”为例：

1. 用户输入 `move 3 4`。
2. ConsoleClient 解析命令，调用 `game.make_move(3,4)`。
3. Game（或子类）检查合法性，更新棋盘、记录历史、切换回合。
4. 前端从棋盘读取状态，重新打印到终端。

整个流程都遵循“客户端不直接碰内部数据”的原则。

---

## 9. 异常处理

* 核心逻辑层遇到非法落子会抛出明确的异常。
* 客户端捕获后输出提示，避免让整个程序崩溃。
* 单元测试对常见异常情形做了覆盖保障。

这里的策略重点是“不要把错误吃掉，也不要让错误向外炸开”，保持清晰可控。

---

## 10. 扩展空间与教学价值

本阶段的结构已经为第二阶段留下自然扩展点：

* 围棋进阶规则（劫争、精确目数计算）
* 加入 AI 对手（可以展示策略模式）
* 做 GUI 版（能体现前后端分离的意义）
* 增加棋谱格式（例如 SGF）

课堂上，教师也可以借此让学生实践添加新棋类，检验工厂与模板方法的设计是否稳健。

---

## 11. 非功能性考量

* **可测试性**：核心逻辑都有单元测试，后续可接 CI。
* **可维护性**：模块划分清晰，不容易“牵一发而动全身”。
* **跨平台性**：纯 Python，无特殊依赖。

---

## 12. 小结

第一阶段完成了一个结构规整、逻辑清晰的棋类平台原型。项目采用合理的抽象与分层，使各部分职责明确，后续扩展不会陷入重写或牵连问题。整体来看，这是一套可以支撑课程展示和后续迭代的干净架构。

